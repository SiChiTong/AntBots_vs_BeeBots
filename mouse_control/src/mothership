#!/usr/bin/env python3
import rospy

import numpy as np
from enum import Enum

from std_msgs.msg import String
from mouse_description.msg import MouseCommand
from mouse_description.msg import MouseData
from mouse_control.msg import GodMail
from mouse_control.msg import UserMail
from mouse_control.msg import Score
import path_finding

# Level 1: Total Omniscience
from mouse_control.msg import Omniscience

WORLD_HEIGHT = rospy.get_param('/WORLD_HEIGHT')
WORLD_WIDTH = rospy.get_param('/WORLD_WIDTH')
reconMap = [[' ' for j in range(WORLD_HEIGHT)] for i in range(WORLD_WIDTH)]

def omniCallback(data):
	for x in range(WORLD_WIDTH):
		for y in range(WORLD_HEIGHT):
			reconMap[x][y] = ' '
	for t, x, y in zip(data.type, data.x, data.y):
		reconMap[x][y] = t

# Comms
def mouseCallback(data, num):
	miceData[num] = data

def godCallback(data):
	global transition
	if state == States.WAITCOMP and data.type == GodMail.COMPUTE:
		transition = True
	elif state == States.WAITMOVE and data.type == GodMail.MOVE:
		transition = True
	else:
		rospy.logerr(f'Unsychronized! {ROLE} {state} {data.type}')

def userCallback(data):
	global usercmd, uservalid
	usercmd = data
	uservalid = True

def scoreCallback(data):
	global score
	score = data

# Helpers
def allAligned():
	return all([d.aligned for d in miceData])

def dist(x1, y1, x2, y2):
	return np.sqrt((y1-y2)**2 + (x1-x2)**2)

def main():
	# connections with its mice
	global miceData, miceControl
	miceData = [None] * NUM
	miceControl = []
	for i in range(NUM):
		rospy.Subscriber(f'{ROLE}{ROLE[1:-2]}{i}/telemetry', MouseData, mouseCallback, i)
		miceControl.append(rospy.Publisher(f'{ROLE}{ROLE[1:-2]}{i}/command', MouseCommand, queue_size=10))

	while not all(miceData):
		pass # wait for mice to bootup and send telemetry

	# state machine setup
	global States, state, transition
	States = Enum('states', 'WAITCOMP WAITMOVE WAITALIGN')
	state = States.WAITALIGN
	transition = False

	# comms with god node
	rospy.Subscriber(f'{ROLE}godTX', GodMail, godCallback)
	godSocket = rospy.Publisher(f'{ROLE}godRX', GodMail, queue_size=10)

	while godSocket.get_num_connections() == 0:
		pass

	global score
	score = Score()
	rospy.Subscriber('/score', Score, scoreCallback)

	# user input
	global usercmd, uservalid, USER
	USER = rospy.get_param(f'{ROLE[:-1].upper()}_USERCONTROL')
	rospy.Subscriber('user', UserMail, userCallback)
	uservalid = False

	# moves to do
	miceMoves = [None] * NUM

	# Level 1: Total Omniscience
	rospy.Subscriber('/omniscience', Omniscience, omniCallback)

	r = rospy.Rate(30)
	while not rospy.is_shutdown():
		if score.gameOver:
			return

		if state == States.WAITCOMP:
			if transition:
				transition = False
				state = States.WAITMOVE

				if USER:
					while not uservalid:
						pass
					for i in range(NUM):
						miceMoves[i] = MouseCommand()
						miceMoves[i].type = usercmd.type[i]
					uservalid = False
				else:
					# TODO perform computation here, all sensor data should be valid
					# DEMO remove later

					flagx, flagy = -1, -1
					for x in range(WORLD_WIDTH):
						for y in range(WORLD_HEIGHT):
							if reconMap[x][y] == 'F':
								
								flagx, flagy = x, y
								print("FLAG HERE:")
								print(flagx, flagy)
					
					if flagx == -1 and flagy == -1:
						print("error: no flag detected")
					
	
					for i in range(NUM):
						current_mouse = miceData[i]
						mx, my = current_mouse.x, current_mouse.y
						mang = current_mouse.ang

						path_array = path_finding.astar(mx, my, flagx, flagy, reconMap, WORLD_HEIGHT, WORLD_WIDTH)
						print(path_array)

						nextx, nexty = 0, 0
						
						if (path_array[mx + 1][my] == (mx, my)):
							nextx = 1
						elif (path_array[mx - 1][my] == (mx, my)):
							nextx = -1
						elif (path_array[mx][my + 1] == (mx, my)):
							nexty = 1
						elif (path_array[mx][my - 1] == (mx, my)):
							nexty = -1
						else:
							print("error: bad path")
						
						miceMoves[i] = MouseCommand()

						print("NEXT")
						print(nextx)
						print(nexty)
						## ONLY TURNING RIGHT FOR TESTING, NOT CORRECTLY TURNING / MOVING YET
						if (nextx == 1):
							# go right
							print("HIT RIGHT")
							miceMoves[i].type = MouseCommand.LEFT
						elif (nextx == -1):
							# go left
							print("HIT LEFT")
							miceMoves[i].type = MouseCommand.LEFT
						elif (nexty == 1):
							#go up
							miceMoves[i].type = MouseCommand.LEFT
						else:
							#go backwards
							miceMoves[i].type = MouseCommand.LEFT

				msg = GodMail()
				msg.type = GodMail.COMPUTED
				godSocket.publish(msg)
		elif state == States.WAITMOVE:
			if transition:
				transition = False
				state = States.WAITALIGN
				for pub, cmd in zip(miceControl, miceMoves):
					pub.publish(cmd)
		elif state == States.WAITALIGN:
			if allAligned():
				state = States.WAITCOMP
				msg = GodMail()
				msg.type = GodMail.ALIGNED
				godSocket.publish(msg)
		else:
			rospy.logerr('Invalid state!')

		r.sleep()

if __name__ == '__main__':
	rospy.init_node('mothership')
	global ROLE, NUM
	ROLE = rospy.get_namespace()
	NUM = rospy.get_param('/NUM_ANTS' if ROLE=='/ants/' else '/NUM_BEES')
	try:
		main()
	except rospy.ROSInterruptException:
		pass