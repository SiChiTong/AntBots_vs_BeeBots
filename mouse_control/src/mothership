#!/usr/bin/env python3
import rospy

import numpy as np
from enum import Enum

from std_msgs.msg import String
from mouse_description.msg import MouseCommand
from mouse_description.msg import MouseData
from mouse_control.msg import GodMail
from mouse_control.msg import UserMail
from mouse_control.msg import Score

# Choose algorithm at the bottom!

# Level 1: Total Omniscience
from mouse_control.msg import Omniscience

WORLD_HEIGHT = rospy.get_param('/WORLD_HEIGHT')
WORLD_WIDTH = rospy.get_param('/WORLD_WIDTH')
reconMap = [[' ' for j in range(WORLD_HEIGHT)] for i in range(WORLD_WIDTH)]

def omniCallback(data):
	for x in range(WORLD_WIDTH):
		for y in range(WORLD_HEIGHT):
			reconMap[x][y] = ' '
	for t, x, y in zip(data.type, data.x, data.y):
		reconMap[x][y] = t

# Comms
def mouseCallback(data, num):
	miceData[num] = data

def godCallback(data):
	global transition
	if state == States.WAITCOMP and data.type == GodMail.COMPUTE:
		transition = True
	elif state == States.WAITMOVE and data.type == GodMail.MOVE:
		transition = True
	else:
		rospy.logerr(f'Unsychronized! {ROLE} {state} {data.type}')

def userCallback(data):
	global usercmd, uservalid
	usercmd = data
	uservalid = True

def scoreCallback(data):
	global score
	score = data

# Helpers
def allAligned():
	return all([d.aligned for d in miceData])

def dist(x1, y1, x2, y2):
	return np.sqrt((y1-y2)**2 + (x1-x2)**2)

def main():
	# connections with its mice
	global miceData, miceControl
	miceData = [None] * NUM
	miceControl = []
	for i in range(NUM):
		rospy.Subscriber(f'{ROLE}{ROLE[1:-2]}{i}/telemetry', MouseData, mouseCallback, i)
		miceControl.append(rospy.Publisher(f'{ROLE}{ROLE[1:-2]}{i}/command', MouseCommand, queue_size=10))

	while not all(miceData):
		pass # wait for mice to bootup and send telemetry

	# state machine setup
	global States, state, transition
	States = Enum('states', 'WAITCOMP WAITMOVE WAITALIGN')
	state = States.WAITALIGN
	transition = False

	# comms with god node
	rospy.Subscriber(f'{ROLE}godTX', GodMail, godCallback)
	godSocket = rospy.Publisher(f'{ROLE}godRX', GodMail, queue_size=10)

	while godSocket.get_num_connections() == 0:
		pass

	global score
	score = Score()
	rospy.Subscriber('/score', Score, scoreCallback)

	# user input
	global usercmd, uservalid, USER
	USER = rospy.get_param(f'{ROLE[:-1].upper()}_USERCONTROL')
	rospy.Subscriber('user', UserMail, userCallback)
	uservalid = False

	# moves to do
	miceMoves = [MouseCommand() for _ in range(NUM)]

	initAlg(ISANT, NUM)

	# Level 1: Total Omniscience
	rospy.Subscriber('/omniscience', Omniscience, omniCallback)

	r = rospy.Rate(30)
	while not rospy.is_shutdown():
		if score.gameOver:
			r.sleep()
			continue

		if state == States.WAITCOMP:
			if transition:
				transition = False
				state = States.WAITMOVE

				if USER:
					while not uservalid:
						pass
					for i in range(NUM):
						miceMoves[i].type = usercmd.type[i]
					uservalid = False
				else:
<<<<<<< HEAD
					# TODO perform computation here, all sensor data should be valid
			
					flagx, flagy = -1, -1
					for x in range(WORLD_WIDTH):
						for y in range(WORLD_HEIGHT):
							if reconMap[x][y] == 'F':
								
								flagx, flagy = x, y
								print("FLAG HERE:")
								print(flagx, flagy)
					
					for i in range(NUM):
						current_mouse = miceData[i]
						mx, my = current_mouse.x, current_mouse.y
						mang = current_mouse.ang

						close_list = path_finding.astar(mx, my, flagx, flagy, reconMap, WORLD_HEIGHT, WORLD_WIDTH)
						print(close_list)

						nextx, nexty = 0, 0
						# (x, y, F, G, parentx, parenty)
						
						for c in close_list:
							if c[4] == mx and c[5] == my:
								nextx = c[0] - mx
								nexty = c[1] - my
						#if (parent_array[mx + 1][my] == (mx, my)):
						#	nextx = 1
						#elif (parent_array[mx - 1][my] == (mx, my)):
						#	nextx = -1
						#elif (parent_array[mx][my + 1] == (mx, my)):
						#	nexty = 1
						#elif (parent_array[mx][my - 1] == (mx, my)):
						#	nexty = -1
						#else:
						#	print("ERROR: NO PATH FOUND TO FLAG!")
						
						miceMoves[i] = MouseCommand()

						if nextx == 1:
							print("GOING EAST")
							if mang == 0:
								miceMoves[i].type = MouseCommand.FORWARD
							else:
								miceMoves[i].type = MouseCommand.LEFT
						elif nextx == -1:
							print("GOING WEST")
							if mang == 2:
								miceMoves[i].type = MouseCommand.FORWARD
							else:
								miceMoves[i].type = MouseCommand.LEFT
						elif nexty == 1:
							print("GOING NORTH")
							if mang == 1:
								miceMoves[i].type = MouseCommand.FORWARD
							else:
								miceMoves[i].type = MouseCommand.LEFT
						elif nexty == -1:
							print("GOING SOUTH")
							if mang == 3:
								miceMoves[i].type = MouseCommand.FORWARD
							else:
								miceMoves[i].type = MouseCommand.LEFT
						else:
							print("ERROR: NO DIRECTION FOUND!")
=======
					computeMoves(miceMoves, score, miceData, reconMap)
>>>>>>> 75dcd3af12bbb159039ec58bfb2f1fc0cb42e646

				msg = GodMail()
				msg.type = GodMail.COMPUTED
				godSocket.publish(msg)
		elif state == States.WAITMOVE:
			if transition:
				transition = False
				state = States.WAITALIGN
				for pub, cmd in zip(miceControl, miceMoves):
					pub.publish(cmd)
		elif state == States.WAITALIGN:
			if allAligned():
				state = States.WAITCOMP
				msg = GodMail()
				msg.type = GodMail.ALIGNED
				godSocket.publish(msg)
		else:
			rospy.logerr('Invalid state!')

		r.sleep()

if __name__ == '__main__':
	rospy.init_node('mothership')
	global ROLE, NUM
	ROLE = rospy.get_namespace()
	ISANT = ROLE == '/ants/'
	NUM = rospy.get_param('/NUM_ANTS' if ISANT else '/NUM_BEES')

	# Choose algorithm here!
	if ISANT:
		from algorithms.template import initAlg, computeMoves
	else:
		from algorithms.template import initAlg, computeMoves

	try:
		main()
	except rospy.ROSInterruptException:
		pass